{-# LANGUAGE BangPatterns      #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes       #-}
{-# LANGUAGE RecordWildCards   #-}

module Main where

import           Control.Monad (foldM, forM_)
import           Data.List (insert)
import           Data.Maybe (fromMaybe)
import           Data.Monoid ((<>))
import           Data.Set (fromList)
import           Data.String.Conv (toS)
import           Language.Javascript.JMacro
import           Options.Applicative (execParser)
import           System.Exit (die)
import           System.IO (IOMode (..), hPutStr, withFile)
import           Text.RawString.QQ (r)
import           Text.Regex.PCRE.Light (Regex, compile, match)

import           Data.Text.I18n.Po (parsePo)
import qualified Data.Text.I18n.Shakespeare as Shakespeare
import           Data.Text.I18n.Types (Msgid(..), MsgDec(..))
import           I18n.CLI

main :: IO ()
main = execParser cliInfo >>= runCli

-- | Interpret description of i18n in IO.
runCli :: Command -> IO ()
runCli (Find opts) = runFind opts
runCli (ToJS opts) = runToJS opts

-- | Interpret the find command in IO.
runFind :: FindOpts -> IO ()
runFind FindOpts { .. } = do
  writeFile findOutput potHeader

  withFile findOutput AppendMode $ \fileHandle -> do
    translations <- fromList <$> foldM gatherTranslations mempty findFiles
    forM_ translations (hPutStr fileHandle)

  where
    gatherTranslations :: [String] -> FilePath -> IO [String]
    gatherTranslations !acc path = do
      source <- readFile path
      case findRegexp of
        Nothing     -> handleOthers acc source
        Just regexp -> handleRegexp acc source (compile (toS regexp) [])

    handleRegexp :: [String] -> String -> Regex -> IO [String]
    handleRegexp !acc source regexp = foldM go acc (lines source)
      where
        go :: [String] -> String -> IO [String]
        go !acc' line =
          case match regexp (toS line) [] of
            Nothing -> return acc'
            Just matches ->
              case matches of
                []                     -> return acc'
                [_]                    -> return acc'
                _:translatableString:_ ->
                  return $! insert (toMessage (toS translatableString)) acc'

    handleOthers :: [String] -> String -> IO [String]
    handleOthers !acc source = do
      let result = Shakespeare.decode (fromMaybe defaultKeyword findKeyword) source
      case result of
        Left err ->
          die err
        Right translations ->
          return $! acc <> fmap toMessage translations

    defaultKeyword :: String
    defaultKeyword = "_"

-- | Interpret the tojs command in IO.
runToJS :: ToJSOpts -> IO ()
runToJS ToJSOpts { .. } = do
  result <- parsePo toJSPOFile
  case result of
    Left err -> die (show err)
    Right messages -> do
      writeFile toJSOutput "/*jshint sub:true*/"
      writeFile toJSOutput "// Autogenerated by i18n"
      withFile toJSOutput AppendMode $ \fileHandle -> do
        hPutStr fileHandle "\n"
        hPutStr fileHandle (toJS messages)

  where
    toJS :: [MsgDec] -> String
    toJS messages = show $ renderJs (defineObject <> mconcat (fmap addToObject messages))

    defineObject :: JStat
    defineObject = [jmacro|
      var !__locales__ = __locales__ || {};
      __locales__[`(toJSLocale)`] = {};
    |]

    addToObject :: MsgDec -> JStat
    addToObject (MsgDec _ (Msgid key) vals) =
      case key of
        "" -> mempty
        _  -> [jmacro| __locales__[`(toJSLocale)`][`(key)`] = `(vals)`; |]

-- | Transform a translation to a message.
toMessage :: String -> String
toMessage translation = unlines ["msgid " <> show translation, "msgstr \"\"", ""]

-- | POT header file.
potHeader :: String
potHeader = [r|# Translation file.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2001-01-01 06:00+0100\n"
"PO-Revision-Date: 2001-01-01 06:00+0100\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

|]
